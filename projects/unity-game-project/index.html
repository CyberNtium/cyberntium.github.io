<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Unity Game Project - Game Programming · cyberntium
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Carl Ho">
<meta name="description" content="
  Preface - Things to Know Before Writing Any Scripts
  
    
    Link to heading
  



void Start() function is called once when the gameObject is first initialised or when the scene starts


void update() function is called every frame (60 times per second if we are doing 60 FPS). This is done for anything that needs continuous checking like player inputs or playing animations



  1. Moving Our Character
  
    
    Link to heading
  

First, we initialize a Rigidbody2D variable as rb. Then, in the void Start() class, we do:">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Unity Game Project - Game Programming">
  <meta name="twitter:description" content="Preface - Things to Know Before Writing Any ScriptsLink to headingvoid Start() function is called once when the gameObject is first initialised or when the scene starts
void update() function is called every frame (60 times per second if we are doing 60 FPS). This is done for anything that needs continuous checking like player inputs or playing animations
1. Moving Our CharacterLink to headingFirst, we initialize a Rigidbody2D variable as rb. Then, in the void Start() class, we do:">

<meta property="og:url" content="https://cyberntium.github.io/projects/unity-game-project/">
  <meta property="og:site_name" content="cyberntium">
  <meta property="og:title" content="Unity Game Project - Game Programming">
  <meta property="og:description" content="Preface - Things to Know Before Writing Any ScriptsLink to headingvoid Start() function is called once when the gameObject is first initialised or when the scene starts
void update() function is called every frame (60 times per second if we are doing 60 FPS). This is done for anything that needs continuous checking like player inputs or playing animations
1. Moving Our CharacterLink to headingFirst, we initialize a Rigidbody2D variable as rb. Then, in the void Start() class, we do:">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="projects">
    <meta property="article:published_time" content="2025-09-09T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-09-09T00:00:00+00:00">
    <meta property="article:tag" content="IM3180">
    <meta property="article:tag" content="Game Dev">
    <meta property="article:tag" content="Unity">
    <meta property="article:tag" content="C#">




<link rel="canonical" href="https://cyberntium.github.io/projects/unity-game-project/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.ebdf1a5dca6a69142e979b32668c69f2a95448b145a168104c5808b14d2b75b0.css" integrity="sha256-698aXcpqaRQul5syZoxp8qlUSLFFoWgQTFgIsU0rdbA=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/img/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="https://cyberntium.github.io/">
      cyberntium
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/blog/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/projects/">Projects</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/studylogs/">Study Log</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/music/">Music</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container page">
  <article>
    <header>
      <h1 class="title">
        <a class="title-link" href="https://cyberntium.github.io/projects/unity-game-project/">
          Unity Game Project - Game Programming
        </a>
      </h1>
    </header>

    <h1 id="preface---things-to-know-before-writing-any-scripts">
  Preface - Things to Know Before Writing Any Scripts
  <a class="heading-link" href="#preface---things-to-know-before-writing-any-scripts">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<ul>
<li>
<p><code>void Start()</code> function is called once when the gameObject is first initialised or when the scene starts</p>
</li>
<li>
<p><code>void update()</code> function is called every frame (60 times per second if we are doing 60 FPS). This is done for anything that needs continuous checking like player inputs or playing animations</p>
</li>
</ul>
<h2 id="1-moving-our-character">
  1. Moving Our Character
  <a class="heading-link" href="#1-moving-our-character">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>First, we initialize a <strong><em>Rigidbody2D</em></strong> variable as <em>rb</em>. Then, in the <code>void Start()</code> class, we do:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>rb = GetComponent&lt;Rigidbody2D&gt;()
</span></span></code></pre></div><p>This is to assign the <em>rb</em> component to the player <em>GameObject</em>, which is why the script is attached to the player in the first place. We do this in the <code>void Start()</code> function because we only want to get the component once and never change it again.</p>
<figure class="center"><img src="https://i.imgur.com/eb9bbyv.png"
    alt="RigidBodyComponent">
</figure>

<p>Unfortunately, this is not enough to move the player.<br>
We need to then declare a private float variable, <em>xAxis</em>. Then, we create a void function, <strong><em>GetInputs()</em></strong>.
Void functions do not return anything, but serve as methods that will be called when a player inputs anything. Thus, next we write inside the <strong><em>GetInputs()</em></strong> method:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>void GetInputs() {
</span></span><span style="display:flex;"><span>    xAxis = Input.GetAxisRaw(&#34;Horizontal&#34;);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>All this does is:</p>
<ul>
<li>Return 1 if player presses right (D or right arrow)</li>
<li>Return -1 if player presses left (A or left arrow)</li>
<li>Return 0 if player does not press anything</li>
</ul>
<p>And stores them into the <em>xAxis</em> float variable.
After this, we create a function <code>private void Move()</code> and insert:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>private void Move() {
</span></span><span style="display:flex;"><span>    rb.linearVelocity = new Vector2(walkSpeed * xAxis, rb.linearVelocity.y);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><em>rb</em> refers to the <em>RigidBody2D</em> component. So, <em>rb.linearVelocity</em> means the linear velocity of the rb which is our player. This will equal the RHS of the equation.</p>
<p>Let’s breakdown the RHS:</p>
<ul>
<li><em>new Vector2D()</em>: This basically means we are initialising a new fresh <em>Vector2D</em> object with values every time <strong><em>Move()</em></strong> is called, which is why we put it inside the <strong><em>Update()</em></strong> function (refer to top)</li>
</ul>
<blockquote>
<p>But what is <em>Vector2D</em>? We all took Physics in our 1st Year, do you remember what is a vector?</p></blockquote>
<ul>
<li>
<p>Unity basically stores the x and y components in a “thing” called Vector2D. We are essentially telling the script to store the velocity component of our inputs to the <em>rb.linearVelocity</em> which will be updated every frame. For example:</p>
</li>
<li>
<ul>
<li>(5, 0) means moving to the right</li>
</ul>
</li>
<li>
<ul>
<li>(-5, 0) means moving to the left</li>
</ul>
</li>
<li>
<ul>
<li>(0, -10) means moving straight down</li>
</ul>
</li>
<li>
<p>Inside the <em>Vector2D()</em>, <em>xAxis * walkSpeed</em> will give us the speed and direction of the player.</p>
</li>
<li>
<p>Why is <em>rb.linearVelocity.y</em> not changed? This is because we already have a gravity function in the RigidBody2D component inside unity:</p>
</li>
<li>
<figure class="center"><img src="https://i.imgur.com/CMsQkHN.png"
    alt="Gravity">
</figure>

</li>
<li>
<p>&hellip;so we can ignore it for now.</p>
</li>
</ul>
<p>Finally, we put the <strong><em>Move()</em></strong> function inside <strong><em>Update()</em></strong>, and our player <em>GameObject</em> can now move when we press our inputs!</p>
<figure class="center"><img src="https://i.imgur.com/W2Qntx2.gif"
    alt="moving">
</figure>

<h2 id="2-jumping">
  2. Jumping
  <a class="heading-link" href="#2-jumping">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h3 id="21-basic-jump-concept">
  2.1 Basic Jump() Concept
  <a class="heading-link" href="#21-basic-jump-concept">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>To make our codes easy to understand, it’s important to keep track of what state the player is at. If we initialise a new state every time a function is called, it is not a very efficient code.<br>
Therefore, let’s make a new script called <code>PlayerStateList</code> to keep track of what state the player is at according to user inputs:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#ff7b72">public</span> <span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">PlayerStateList</span> : MonoBehaviour 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">public</span> <span style="color:#ff7b72">bool</span> jumping = False; <span style="color:#8b949e;font-style:italic">//Don&#39;t forget this is in the PlayerStateList script</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let jumping to be false by default since the player should not be jumping at the start of the game for no reason. Then, we need to reference this to the player controller file in the Start function:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#ff7b72">void</span> Start ()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    pState = GetComponent&lt;PlayerStateList&gt;();
</span></span><span style="display:flex;"><span>    rb = GetComponent&lt;Rigidbody2D&gt;(); <span style="color:#8b949e;font-style:italic">// From Move()</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>pState</code> stands for player state, this line looks for the component PlayerStateList which is the script we made just now. Now go back to Unity and drag the PlayerStateList script onto the Player gameObject.</p>
<p>Let&rsquo;s talk about the actual jump function now:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#ff7b72">if</span> (Input.GetButtonUp(<span style="color:#a5d6ff">&#34;Jump&#34;</span>) &amp;&amp; rb.linearVelocity.y &gt; <span style="color:#a5d6ff">0</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    rb.linearVelocity = <span style="color:#ff7b72">new</span> Vector2(rb.linearVelocity.x, <span style="color:#a5d6ff">0</span>);
</span></span><span style="display:flex;"><span>    pState.jumping = <span style="color:#79c0ff">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is the first part of <code>Jump()</code>:</p>
<ul>
<li><code>Input.GetButtonUp(“Jump”)</code> basically means the moment immediately after you pressed and RELEASE the “Jump” button (in this case is Spacebar)</li>
<li><code>rb.linearVelocity.y</code> checks if the rigidbody of Player is still moving upwards</li>
<li><code>rb.linearVelocity = new Vector2(rb.linearVelocity.x, 0)</code></li>
<li>This creates a new Vector2 with:</li>
<li>
<ul>
<li><code>rb.linearVelocity.x</code>, this is your current horizontal movement, meaning you keep all your momentum in the X-axis, that’s why you can jump left and right.
Set your Y component to zero. This means that you kill upwards velocity</li>
</ul>
</li>
<li>
<ul>
<li>This ultimately means that you stop going higher the moment you release the “Jump” button.</li>
</ul>
</li>
<li>Finally, we set <code>pState.jumping = false</code> because we have in fact stopped jumping after releasing the “Jump” button</li>
</ul>
<p>And that’s basically how the main <code>Jump()</code> would work in an ideal scenario.</p>
<h3 id="22-grounded">
  2.2 Grounded()
  <a class="heading-link" href="#22-grounded">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Let&rsquo;s go through the <code>Grounded()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#ff7b72">public</span> <span style="color:#ff7b72">bool</span> Grounded()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">if</span> (Physics2D.Raycast(groundCheckPoint.position, Vector2.down, groundCheckY, whatIsGround)
</span></span><span style="display:flex;"><span>        || Physics2D.Raycast(groundCheckPoint.position + <span style="color:#ff7b72">new</span> Vector3(groundCheckX, <span style="color:#a5d6ff">0</span>, <span style="color:#a5d6ff">0</span>), Vector2.down, groundCheckY, whatIsGround)
</span></span><span style="display:flex;"><span>        || Physics2D.Raycast(groundCheckPoint.position + <span style="color:#ff7b72">new</span> Vector3(-groundCheckX, <span style="color:#a5d6ff">0</span>, <span style="color:#a5d6ff">0</span>), Vector2.down, groundCheckY, whatIsGround))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We declare a public method called <code>Grounded()</code> that returns a boolean value, true or false.</p>
<p>Then, let’s explain what is <code>Physics2D.Raycast</code>:</p>
<p>The general formula or format for this function is as follows:</p>
<p><strong><em>Physics2D.Raycast(origin, direction, distance, layerMask)</em></strong></p>
<p>Physics2D.Raycast function shoots an invisible ray according to your configuration and reports if the ray hits something in game. You can imagine it as a sensor in the form of a layer pointer.</p>
<ul>
<li>
<p>origin = a vector2 that specifies the starting point of your Raycast</p>
</li>
<li>
<p>direction = a vector 2 that defines the angle/path of your Raycast. Is it up or down or 45 degrees up and so on</p>
</li>
<li>
<p>distance = this is a float that we can customise for the maximum length of the Raycast which it can travel before cutting off</p>
</li>
<li>
<p>layerMask = this is an integer that filters which gameObject the Raycast can see. If you look at top right when you have a gameObject selected you can see:</p>
</li>
<li>
<figure class="center"><img src="https://i.imgur.com/wxyICVd.png"
    alt="layerMask">
</figure>

</li>
<li>
<p>Layer = Ground, which we have set it to be since it’s the floor</p>
</li>
</ul>
<p>Now, let&rsquo;s go back to our orignal Raycast:</p>
<p><code>Physics2D.Raycast(groundCheckPoint.position, Vector2.down, groundCheckY, whatIsGround)</code></p>
<p>These are some new variables, so let’s initialise them above:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>[Header(&#34;Ground Check Settings:&#34;)]
</span></span><span style="display:flex;"><span>[SerializeField] <span style="color:#ff7b72">private</span> Transform groundCheckPoint;
</span></span><span style="display:flex;"><span>[SerializeField] <span style="color:#ff7b72">private</span> <span style="color:#ff7b72">float</span> groundCheckY = <span style="color:#a5d6ff">0.2f</span>;
</span></span><span style="display:flex;"><span>[SerializeField] <span style="color:#ff7b72">private</span> <span style="color:#ff7b72">float</span> groundCheckX = <span style="color:#a5d6ff">0.5f</span>;
</span></span><span style="display:flex;"><span>[SerializeField] <span style="color:#ff7b72">private</span> LayerMask whatIsGround;
</span></span></code></pre></div><ul>
<li>
<p><code>groundCheckPoint</code> is declared as a public field under your PlayerController, thus we can link it with an empty gameObject as a child under the Player gameObject and drag it to be at our player’s feet or most bottom position like so:</p>
</li>
<li>
<figure class="center"><img src="https://i.imgur.com/FVMlFVB.png"
    alt="stuff">
</figure>

</li>
<li>
<p>And then finally, we drag the empty gameObject “Ground Check Point” to the public field that we declared just now in PlayerController:</p>
</li>
<li>
<figure class="center"><img src="https://i.imgur.com/OSsRWgM.png"
    alt="text">
</figure>

</li>
<li>
<p>groundCheckY is declared as a float type, that represents the length of the Raycast</p>
</li>
<li>
<p>groundCheckX is the offset of the Raycast in the horizontal axis, which will be explained later</p>
</li>
<li>
<p>whatIsGround is basically checking what type of layer what we want our Raycast is hitting, in this case will be ground, which we need to indicate in Unity when saving the script:</p>
</li>
<li>
<figure class="center"><img src="https://i.imgur.com/opLxWSs.png"
    alt="layerMask">
</figure>

</li>
<li>
<p>After everything here, let’s go back to the main Ground() function:</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#ff7b72">public</span> <span style="color:#ff7b72">bool</span> Grounded()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">if</span> (Physics2D.Raycast(groundCheckPoint.position, Vector2.down, groundCheckY, whatIsGround)
</span></span><span style="display:flex;"><span>        || Physics2D.Raycast(groundCheckPoint.position + <span style="color:#ff7b72">new</span> Vector3(groundCheckX, <span style="color:#a5d6ff">0</span>, <span style="color:#a5d6ff">0</span>), Vector2.down, groundCheckY, whatIsGround)
</span></span><span style="display:flex;"><span>        || Physics2D.Raycast(groundCheckPoint.position + <span style="color:#ff7b72">new</span> Vector3(-groundCheckX, <span style="color:#a5d6ff">0</span>, <span style="color:#a5d6ff">0</span>), Vector2.down, groundCheckY, whatIsGround))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Inside the if statement, we are checking if:</p>
<ul>
<li>groundCheckPoint.position = position at our feet</li>
<li>Vector2.down = downward direction</li>
<li>groundCheckY = length of 0.2f</li>
<li>whatIsGround = checking of gameObjects tagged with “Ground”</li>
</ul>
<p>OR:</p>
<ul>
<li>groundCheckPoint.position + new Vector3(groundCheckX, 0, 0) …</li>
</ul>
<p>AND:</p>
<ul>
<li>groundCheckPoint.position + new Vector3(-groundCheckX, 0, 0) …</li>
</ul>
<p>What the heck are these two ORs inside the if statement:<br>
Starting at the original place at the Player’s feet, we do an offset of groundCheckX = 0.5 and -0.5 to ensure that even if the player is a bit off the ground, the player will still be considered grounded. A simple illustration is this:
<figure class="center"><img src="https://i.imgur.com/x48n7MP.jpeg"
    alt="raycast">
</figure>
</p>
<blockquote>
<p>Another question is why use Vector3 for the offsets?</p></blockquote>
<p>Well, Unity’s Transform has always been in 3D even if the game we are developing is in 2D. Thus, when we use something.position, the .position returns a Vector3 component, so if we just do <code>something.position + new Vector2(groundCheckX, 0, 0)</code>, this will give us an error because a Vector3 cannot be added to a Vector2 directly.</p>
<h3 id="23-updatejumpvariables">
  2.3 UpdateJumpVariables()
  <a class="heading-link" href="#23-updatejumpvariables">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Let&rsquo;s initialise some variables first:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>[Header(&#34;Vertical Movement Settings:&#34;)]
</span></span><span style="display:flex;"><span>[SerializeField] <span style="color:#ff7b72">private</span> <span style="color:#ff7b72">float</span> jumpForce = <span style="color:#a5d6ff">45</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">private</span> <span style="color:#ff7b72">int</span> jumpBufferCounter = <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex;"><span>[SerializeField] <span style="color:#ff7b72">private</span> <span style="color:#ff7b72">int</span> jumpBufferFrames;
</span></span><span style="display:flex;"><span>prviate <span style="color:#ff7b72">float</span> coyoteTimeCounter = <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex;"><span>[SerializeField] <span style="color:#ff7b72">private</span> <span style="color:#ff7b72">float</span> coyoteTime;
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">private</span> <span style="color:#ff7b72">int</span> airJumpCounter = <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex;"><span>[SerializeField] prviate <span style="color:#ff7b72">int</span> maxAirJump;
</span></span></code></pre></div><ul>
<li>jumpForce, a float type that is serializable in Unity is basically the strength of our player’s jump</li>
<li>jumpBufferCounter is an int type that is used in the jump buffer logic. It is set as zero at start. Explained later</li>
<li>jumpBufferFrames is a serializable int type that can be adjusted in game which defines how long the jump buffer would last. Explained later.</li>
<li>coyoteTimeCounter is another int type that is used to track coyote time. Not serializable.</li>
<li>coyoteTime is a serializable type that represents the coyote time and how long it lasts. Explained later</li>
<li>airJumpCounter is an int that functions as a counter that tracks how many times the player has jumped. Not serializable.</li>
<li>maxAirJump, serializable, the total amount of jumps the player is allowed to make. Explained later.</li>
</ul>
<p>Let’s start with the UpdateJumpVariable() function:</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#ff7b72">void</span> updateJumpVariables() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">if</span> (Grounded()) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        p.State.jumping = <span style="color:#79c0ff">false</span>;
</span></span><span style="display:flex;"><span>        coyoteTimeCounter = coyoteTime;
</span></span><span style="display:flex;"><span>        airJumpCounter = <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex;"><span>        coyoteTimeCounter -= Time.deltaTime;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">if</span> (Input.GetButtonDown(<span style="color:#a5d6ff">&#34;Jump&#34;</span>)) {
</span></span><span style="display:flex;"><span>        jumpBufferCounter = jumpBufferFrames;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex;"><span>        jumpBufferCounter --;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>The first if statement checks if the player is Grounded() or touching the ground (explained just now). If the player is touching the ground, we set the jumping player state to be false.<br>
We also set the coyoteTimeCounter to be assigned to the coyoteTime we set in Unity, or another way of saying, reset the coyoteTimeCounter. We also reset our airJumpCounter back to 0 so that players can double jump again after landing on ground.</p>
</li>
<li>
<p>If the player is not touching ground however, we set <code>coyoteTimeCounter -= Time.deltaTime</code>. This basically means that coyoteTimeCounter continuously counts down by subtracting its value by time.deltaTime which is the seconds since the last frame until coyoteTime runs out.</p>
</li>
<li>
<p>The next if statement checks if the “Jump” button was pressed at a particular point of time. Then we set jumpBufferCounter to be equal to jumpBufferFrames, meaning resetting the jump buffer counter to its max value. Thus, when you land soon, you will still jump automatically.</p>
</li>
<li>
<p>The else statement here checks if the “Jump” button was not pressed in this frame, if so, it decreases the jump buffer counter continuously eventually reaching zero and “forgets” the jump input.</p>
</li>
</ul>
<h3 id="24-final-jump-method">
  2.4 Final Jump() Method
  <a class="heading-link" href="#24-final-jump-method">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#ff7b72">void</span> Jump() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">if</span> (Input.GetButtonUp(<span style="color:#a5d6ff">&#34;Jump&#34;</span>) &amp;* rb.linearVelocity.y &gt; <span style="color:#a5d6ff">0</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        rb.linearVelocity = <span style="color:#ff7b72">new</span> Vector2(rb.linearVelocity.x, <span style="color:#a5d6ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        pState.jumping = <span style="color:#79c0ff">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">if</span> (!pState.jumping) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> (jumpBufferCounter &gt; <span style="color:#a5d6ff">0</span> &amp;&amp; coyoteTimeCounter &gt; <span style="color:#a5d6ff">0</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            rb.linearVelocity = <span style="color:#ff7b72">new</span> Vector2(rb.linearVelocity.x, jumpForce);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            pState.jumping = <span style="color:#79c0ff">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">if</span> (!Grounded() &amp;&amp; airJumpCounter &lt; maxAirJump &amp;&amp; Input.GetButton(<span style="color:#a5d6ff">&#34;Jump&#34;</span>)) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            pState.jumping = <span style="color:#79c0ff">true</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            airJumpCounter ++;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            rb.linearVelocity = <span style="color:#ff7b72">new</span> Vector2(rb.linearVelocity.x, jumpForce);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The first if statement was already explained in section 2.1, the rest implements all the other components into our Jump() method.</p>
<p>The 2nd if statement checks if the “Jump” has been pressed, then we run everything inside the block, which consists of nested statements:</p>
<ul>
<li>
<p>1st IF: this checks if the player pressed the “jump” button within the last frames. Also, it checks if the coyote time is above zero</p>
</li>
<li>
<p>If both these conditions check out, we do:</p>
</li>
<li>
<ul>
<li><code>rb.linearVelocity = new Vector2(rb.linearVelocityX, jumpForce);</code></li>
</ul>
</li>
<li>
<ul>
<li>We set our player’s rigidBody linearVelocity to a new Vector2 like in the very first IF statement: for x component, since we want to keep the horizontal movement, it&rsquo;s the same. But for the Y component, we set it to be jumpForce which we have initialised earlier.</li>
</ul>
</li>
<li>
<ul>
<li>We set the player jump state to be True to prevent spamming the button.</li>
</ul>
</li>
<li>
<ul>
<li>Finally we set the jumpBufferCounter to be zero to prevent another jump to be triggered.</li>
</ul>
</li>
<li>
<p>ELSE IF statement: This checks if the player is not ground and the player has not reached their max air jumps:</p>
</li>
<li>
<ul>
<li>If all these conditions are true:</li>
</ul>
</li>
<li>
<ul>
<li>We set player jumping state to be True</li>
</ul>
</li>
<li>
<ul>
<li>We increase the air jump counter by 1</li>
</ul>
</li>
<li>
<ul>
<li>Finally, we set the player rigidBody linearVelocity to a new Vector2:</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>Where we keep the same horizontal movement, but set the vertical Y component to the jumpForce.</li>
</ul>
</li>
</ul>
</li>
</ul>

  </article>
</section>

  

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2025
     Carl Ho 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>
</html>
